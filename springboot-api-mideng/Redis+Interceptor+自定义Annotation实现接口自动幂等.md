# 幂等实现方案
> - 幂等
>
>   对于同一笔业务操作，不管调用多少次，得到的结果都是一样的。
>
> - 幂等性
>
>   幂等性是系统服务对外一种承诺，承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。
>
> - 默认
>
>    `DELETE`   `SELECT`  是天然幂等的操作
>
> ​	    `UPDATE` 直接更新某个值是幂等的，但如果更新是累加的则不是幂等
>
> ​	   `INSERT` 不是幂等操作



### 一、产生重复请求的原因

```markdown
1. 多次点击提交按钮
2. 点击刷新按钮
3. 使用浏览器后退按钮，导致重复之前的提交操作
4. 使用浏览器历史记录重复提交表单
5. 浏览器重复的 HTTP 请求
6. nginx 重发的情况
7. 分布式系统 RPC 框架的重试请求
8. 网络波动
9. MQ 消息重复
```





### 三、接口幂等的实现方案

#### 前端方案
```markdown
1. 按钮只能点击一次：按钮置灰或者loading状态，防止用户再次点击
2. token机制：产品设计允许重复，则通过token判断是否是同一请求
3. 重定向机制：Post-Redirect-Get模式，当用户提交表单后端处理完成后，跳转另一个成功或失败的页面。避免用    户F5刷新导致重复提交
```

#### 后端方案

##### 1. 基于TOKEN机制
```markdown
1. 每次请求接口前,都先调用获取token接口，获取请求接口的token
2. 携带token请求接口，接口校验token是否存在(在第一步获取token后可以保存在集中存储redis中,校验时从 	    redis取)
3. 存在：则不是重复请求,允许执行后面的业务逻辑。同时删除token
4. 如果不存在：则认为是重复请求，直接返回
TOKEN机制的弊端
1. 缓存和数据库不一致问题
   a. 先删除token,后执行业务; 
   b. 先执行业务,后删除token;
2. 每次请求都要获取token
```

##### 2. 多版本控制(乐观锁机制)

```markdown
乐观锁机制： 通常是通过数据库的版本号 version来实现; 

乐观锁：主要处理读多写少的问题
1. 每次更新前先查询数据的版本号
2. 更新时，在条件中加入查询获取的版本号。
   版本号一致则更新成功，不一致则更新失败(不一致说明，数据已经被修过了)
```

##### 3. 防重表

```markdown
防重表的思路是：加锁的功能。需要增加一个防重表，并设计好唯一索引
1. 使用全局唯一标识做为去重表的唯一索引。把唯一标识插入去重表在执行业务逻辑,且要保证他们在同一个事务中。
```

##### 4. 状态机控制

> - 个人理解：状态机也是 (select+insert)的一种

```markdown
适合在有状态机流转的情况下

在设计时最好只支持状态的单向改变(不可逆)
例如：电商系统中的 订单状态的变更
```

##### 5. 全局唯一ID

> 全局唯一ID： 根据业务的操作和内容生成一个全局唯一的ID，在执行操作前先查询ID是否存在，来判断这个      		 			   操作是否已经执行。

```markdown
5-1. 唯一主键(唯一索引)
     这个机制利用了数据库的主键唯一约束的特性。但要求主键全局唯一
     唯一主键的问题：在分库分表的场景下,路由规则要保证相同的请求落在同一个数据库和同一张表中。否则唯一主键				  约束就不起作用了
   
5-2. 插入或更新(select+insert)
     先查询在插入
     通过一些确定的【关键字】查询数据，判断是否执行过。根据查询结果判断是否继续执行

5-3. 分布式锁机制(也需要一个唯一的token或ID)
     [<< 锁的本质：也是在排队 >>]
     分布式锁的机制：类似于防重表,把防重并发放到了缓存中。

5-4. 对外提供的API如何保证幂等
     接口请求附带：source(来源) + seq (序列号)
     source+seq在数据库做唯一索引，只处理一个请求。
     
     对外提供接口为了支持幂等：source(来源) + seq (序列号) 必传
```

##### 6. 悲观锁机制

> - 借助数据库 select .. for update 
>
> 同时要借助 数据库的唯一索引约束方可实现

##### 7. 缓存队列

```markdown
使用队列把请求快速接下,放入缓存队列。使用异步任务去处理队列的数据，同时过滤掉重复请求。
队列可以用LinkedList来实现,HasHSet来实现去重。

优点：
1. 异步处理，高吞吐量
缺点：
1. 请求结果不能及时返回，需要后续轮询处理结果
```



### 四、幂等实现方案DEMO

##### 基于注解+拦截实现幂等

> `Redis+Interceptor`+自定义 `Annotation` 实现接口自动幂等
> [`Spring Boot+Redis+Interceptor+自定义Annotation`实现接口自动幂等](https://www.jianshu.com/p/c806003a8530)
> 个人理解对 幂等的理解不是很清楚：实现很大程度上是基于 防重复提交的思路来

★★★
[`SpringBoot自定义Annotation`实现通用的接口自动幂等](https://blog.csdn.net/weixin_38405253/article/details/105154104)



### 五、参考文档

[如何避免重复提交？分布式服务的幂等性设计！](https://mp.weixin.qq.com/s/K1PEjOonEZiS7PUGyjjObA)

[一口气说出8种幂等性解决重复提交的方案，面试官懵了！(附代码)](https://mp.weixin.qq.com/s/bo0CFj0FRT74qUXQEucOxQ)

[微服务架构之幂等性问题及设计思想](https://mp.weixin.qq.com/s/DXqT6aEgTbLjsthxtbg2sg)

★★★结合具体场景的一些分析
[接口幂等性这么重要，它是什么？怎么实现？](https://cloud.tencent.com/developer/article/1511743)

★★★ 这两篇博文总结的非常好,深入到具体的业务场景中通过伪代码进行说明
[如何避免下重复订单](https://www.jianshu.com/p/e618cc818432)
[关于接口幂等性的总结](https://www.jianshu.com/p/6eba27f8fb03)


★★★ 美团分享
[分布式系统互斥性与幂等性问题的分析与解决](https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html)